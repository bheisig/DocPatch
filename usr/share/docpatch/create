#!/bin/bash


## DocPatch -- patching documents that matter
## Copyright (C) 2012 Benjamin Heisig <http://benjamin.heisig.name/>
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.


##
## Create script
##


## About this command:
COMMAND_DESC="$COMMAND_CREATE"


## 'pdf' is one more supported output format:
SUPPORTED_FORMATS="epub html man pdf text"


## Checks wether everything is prepared before creating output.
function checks {
  loginfo "Checking wether everything is prepared before creating output..."

  logdebug "Checking output directory..."
  if [ ! -d "$OUTPUT_DIR" ]; then
      logdebug "Output directory not found. Create it."
      exe "$MKDIR -p $OUTPUT_DIR"
      if [ "$?" -gt 0 ]; then
          logwarning "Cannot create output directory under ${OUTPUT_DIR}."
          logerror "Checks failed."
          return 1
        fi
      logdebug "Output directory created under ${OUTPUT_DIR}."
    else
      logdebug "Output directory found in ${OUTPUT_DIR}."
    fi

  logdebug "Verifying format..."
  local found=0
  for format in $SUPPORTED_FORMATS; do
      if [ "$OUTPUT_FORMAT" == "$format" ]; then
          found=1
          break
        fi
    done
  if [ "$found" -eq 0 ]; then
      logwarning "Format is not supported: $OUTPUT_FORMAT"
      logerror "Checks failed."
      return 1
    fi
  logdebug "Format verified: $OUTPUT_FORMAT"

  logdebug "Checks succeded."
  return 0
}


## Fetches supported output formats:
## FIXME Parse and match output_formats.txt
function fetchSupportedOutputFormats {
  loginfo "Fetching supported output formats..."

  logdebug "Fetching raw formats..."
  local formats=`"$PANDOC" --help | "$GREP" 'Output formats' | "$AWK" 'BEGIN{FS="  "}{print $NF}'`

  logdebug "Parsing formats..."
  IFS=", "
  for supported_format in $formats; do
      if [ -n "$SUPPORTED_FORMATS" ]; then
          SUPPORTED_FORMATS="$SUPPORTED_FORMATS "
        fi
      $SUPPORTED_FORMATS="${SUPPORTED_FORMATS}$supported_format"
      logdebug "Appended output format $supported_format to list."
    done
  unset IFS

  logdebug "Fetched supported output formats."
  return 0
}


## Loads meta information
function loadMetaInformation {
  loginfo "Loading meta information..."

  if [ ! -r "$DOCPATCH_CONF_TARGET" ]; then
      logwarning "Cannot access meta information under ${DOCPATCH_CONF_TARGET}."
      logerror "Failed to load meta information."
      return 1
    fi
  logdebug "Meta information found under ${DOCPATCH_CONF_TARGET}."

  logdebug "Including file..."
  source "$DOCPATCH_CONF_TARGET"
  logdebug "File included."

  logdebug "Meta information loaded."
  return 0
}


## Determines Repository
function determineRepository {
  loginfo "Determining repository..."

  logdebug "Checking argument..."
  if [ -z "$REPOSITORY" ]; then
      logdebug "Argument not set. Use default repository under ${REPO_DIR}."

      logdebug "Checking for existing repository..."
      if [ ! -d "${REPO_DIR}/.git/" ]; then
          lognotice "There is no repository under ${REPO_DIR}."
          logwarning"Cannot use default repository."
          logerror "Failed to determine repository."
          return 1
        fi
      logdebug "Repository found under ${REPO_DIR}."
    else
      logdebug "Cloning repository ${REPOSITORY}..."

      logdebug "Checking for existing repository..."
      if [ -d "${REPO_DIR}/.git/" ]; then
          lognotice "Repository found under ${REPO_DIR}."
          logwarning"Cannot clone repository ${REPOSITORY}."
          logerror "Failed to determine repository."
          return 1
        fi
      logdebug "There is no repository under ${REPO_DIR}."

      logdebug "Creating empty directory..."
      exe "$RM -rf $REPO_DIR"
      exe "$MKDIR -p $REPO_DIR"
      logdebug "Empty directory under $REPO_DIR created."

      logdebug "Cloning repository from ${REPOSITORY}..."
      exe "$GIT clone $REPOSITORY $REPO_DIR"
      if [ "$?" -gt 0 ]; then
          logwarning"Cannot clone repository $REPOSITORY under ${REPO_DIR}."
          logerror "Failed to determine repository."
          return 1
        fi
      logdebug "Repository cloned under ${REPO_DIR}."
    fi

  logdebug "Repository determined."
  return 0
}


## Counts revisions.
function countRevisions {
  loginfo "Counting revisions..."

  cd "$REPO_DIR"
  REVISIONS=`"$GIT" tag -l | "$WC" -l`
  if [ "$?" -gt 0 ]; then
      logerror "Cannot count revisions."
      return 1
    fi
  if [ "$REVISIONS" -eq 1 ]; then
      logdebug "There is 1 revision."
    else
      logdebug "There are $REVISIONS revisions."
    fi

  logdebug "Revisions counted."
  return 0
}


## Determines which revisions are meant.
function determineRevisions {
  loginfo "Determining revisions..."

  logdebug "Parsing argument for revisions..."
  if [ -z "$ARG_REVISION" ]; then
      logdebug "No specific revision given. Assuming first revision."
      LIST_OF_REVISIONS=0
    elif [ "$ARG_REVISION" == "first" ]; then
      logdebug "It's the first revision."
      LIST_OF_REVISIONS=0
    elif [ "$ARG_REVISION" == "last" ]; then
      logdebug "It's the last revision."
      LIST_OF_REVISIONS=$(($REVISIONS - 1))
    elif [ "$ARG_REVISION" == "all" ]; then
      logdebug "All revisions selected."

      for (( rev=0; rev < "$REVISIONS"; rev++ )); do
          if [ "$rev" -lt 0 ]; then
              logwarning"Inproperly named revision found: $rev"
              logerror "Failed to determine revisions."
              return 1
            fi

          if [ -n "$LIST_OF_REVISIONS" ]; then
              LIST_OF_REVISIONS="$LIST_OF_REVISIONS "
            fi

          LIST_OF_REVISIONS="${LIST_OF_REVISIONS}$rev"
          logdebug "Appended revision $rev to list."
        done
    elif [[ "$ARG_REVISION" == ${ARG_REVISION//[^0-9]/} ]]; then
      if [ "$ARG_REVISION" -lt 0 ]; then
          logwarning"Inproperly named revision found: $ARG_REVISION"
          logerror "Failed to determine revisions."
          return 1
        fi
      logdebug "Revision $ARG_REVISION is meant."
      LIST_OF_REVISIONS="$ARG_REVISION"
    else
      logdebug "Looking for more than one revision..."
      IFS=","
      for rev in $ARG_REVISION; do
          if [ "$rev" -lt 0 ]; then
              logwarning"Argument for one or more revisions is invalid."
              logerror "Failed to determine revisions."
              return 1
            fi

          if [ -n "$LIST_OF_REVISIONS" ]; then
              LIST_OF_REVISIONS="$LIST_OF_REVISIONS "
            fi
          LIST_OF_REVISIONS="${LIST_OF_REVISIONS}$rev"
          logdebug "Appended revision $rev to list."
        done
      unset IFS
    fi
  logdebug "Found these revisions: $LIST_OF_REVISIONS"

  logdebug "Revisions determined."
  return 0
}


## Switches repository to a revision.
##   $1 Revision
function switchRevision {
  loginfo "Switching revision..."

  logdebug "Changing into directory ${REPO_DIR}..."
  cd "$REPO_DIR"

  logdebug "Checking out revision ${1}..."
  exe "$GIT checkout $1"
  if [ "$?" -gt 0 ]; then
      logwarning"Cannot checkout revision ${1}."
      logerror "Failed to switch revision."
      return 1
    fi
  logdebug "Check out done."

  logdebug "Revision switched."
  return 0
}


## Creates output.
function createOutput {
  loginfo "Creating output..."

  logdebug "Iterating through each destinated revision..."
  for REVISION in $LIST_OF_REVISIONS; do
      logdebug "Handling revision ${REVISION}..."

      switchRevision "$REVISION"
      if [ "$?" -gt 0 ]; then
          logwarning"Cannot handle revision ${REVISION}."
          logerror "Failed to create output."
          return 1
        fi

      loadMetaInformation "$REVISION"
      if [ "$?" -gt 0 ]; then
          logwarning"Cannot handle revision ${REVISION}."
          logerror "Failed to create output."
          return 1
        fi

      local status=0
      case "$OUTPUT_FORMAT" in
          "epub")
            produceEPUB "$REVISION"
            local status="$?";;
          "html")
            produceManPage "$REVISION"
            local status="$?";;
          "man")
            produceManPage "$REVISION"
            local status="$?";;
          "pdf")
            producePDF "$REVISION"
            local status="$?";;
          "text")
            produceText "$REVISION"
            local status="$?";;
          *) logerror "Internal error."; return 1;;
        esac
      if [ "$status" -gt 0 ]; then
          logwarning"Cannot handle revision ${REVISION}."
          logerror "Failed to create output."
          return 1
        fi

      logdebug "Handling done."
    done
  logdebug "Iteration done."

  logdebug "Output created."
  return 0
}


## Produces EPUB file.
##   $1 Revision
function produceEPUB {
  loginfo "Producing EPUB..."

  # TODO create metadata.xml
  # TODO --epub-metadata=tpl/metadata.xml --epub-cover-image=tpl/test.png

  local output_file="${OUTPUT_DIR}/${IDENTIFIER}.epub"
  logdebug "Producing file..."
  exe "$PANDOC --from=$INPUT_FORMAT --toc --output=$output_file --smart ${REPO_DIR}/*$INPUT_FORMAT_EXT"
  if [ "$?" -gt 0 ]; then
      logwarning "Cannot produce file ${output_file}."
      logerror "Failed to produce EPUB."
      return 1
    fi
  logdebug "Wrote content to file ${output_file}."

  logdebug "EPUB produced."
  return 0
}


## Produces HTML.
##   $1 Revision
function produceHTML {
  loginfo "Producing HTML..."

  local output_file="${OUTPUT_DIR}/${IDENTIFIER}.html"
  logdebug "Producing file..."
  exe "$PANDOC --from=$INPUT_FORMAT --to=html --toc --standalone --smart --output=$output_file ${REPO_DIR}/*$INPUT_FORMAT_EXT"
  if [ "$?" -gt 0 ]; then
      logwarning "Cannot produce file ${output_file}."
      logerror "Failed to produce HTML."
      return 1
    fi
  logdebug "Wrote content to file ${output_file}."

  logdebug "HTML produced."
  return 0
}


## Produces man page.
##   $1 Revision
function produceManPage {
  loginfo "Producing man page..."

  local output_file="${OUTPUT_DIR}/${IDENTIFIER}.txt"
  logdebug "Producing file..."
  exe "$PANDOC --from=$INPUT_FORMAT --to=man --standalone ${REPO_DIR}/*$INPUT_FORMAT_EXT | $GZIP -c > ${output_file}.1.gz"
  if [ "$?" -gt 0 ]; then
      logwarning "Cannot produce file ${output_file}."
      logerror "Failed to produce man page."
      return 1
    fi
  logdebug "Wrote content to file ${output_file}."

  logdebug "Man page produced."
  return 0
}


## Produces PDF file.
##   $1 Revision
function producePDF {
  loginfo "Producing PDF..."

  logdebug "Checking for any template file..."
  local tpl_option=""
  local tpl_file="${TPL_DIR}/tpl.tex"
  if [ -r "$tpl_file" ]; then
      logdebug "Template file found under ${tpl_file}."
      local tpl_option="--template=$tpl_file"
    else
      logdebug "No template file found under ${tpl_file}."
    fi

  local output_file="${OUTPUT_DIR}/${IDENTIFIER}.pdf"
  logdebug "Producing file..."
  exe "$MARKDOWN2PDF --from=$INPUT_FORMAT --toc $tpl_option --output=$output_file ${REPO_DIR}/*$INPUT_FORMAT_EXT"
  if [ "$?" -gt 0 ]; then
      logwarning "Cannot produce file ${output_file}."
      logerror "Failed to produce PDF."
      return 1
    fi
  logdebug "Wrote content to file ${output_file}."

  logdebug "PDF produced."
  return 0
}


## Produces plaintext files.
##   $1 Revision
function produceText {
  loginfo "Producing plaintext..."

  local output_file="${OUTPUT_DIR}/${IDENTIFIER}.txt"
  logdebug "Producing file..."
  exe "$PANDOC --from=$INPUT_FORMAT --output=$output_file --to=plain --standalone ${REPO_DIR}/*$INPUT_FORMAT_EXT"
  if [ "$?" -gt 0 ]; then
      logwarning "Cannot produce file ${output_file}."
      logerror "Failed to produce plaintext."
      return 1
    fi
  logdebug "Wrote content to file ${output_file}."

  logdebug "Plaintext produced."
  return 0
}


## Main method
function main {
  checks || abort 21

  countRevisions || abort 22

  determineRepository || abort 23

  determineRevisions || abort 24

  #fetchSupportedOutputFormats || abort 25

  createOutput || abort 26
}


## Prints command specific options.
function printCommandOptions {
  loginfo "Printing command specific options..."

  local formats=""
  for format in $SUPPORTED_FORMATS; do
      if [ -n $formats ]; then
          $formats="${formats}, "
        fi
      $formats="${formats}'$format'"
    done

  prntLn "    -f, --format, --output\t\tSelect output format FORMAT. Supported formats are ${formats}. Defaults to 'pdf'."
  prntLn "    -r, --rev, --revision REV\t\tGenerate output from revision REV. 'first', 'last', 'all' and a comma separated list of revisions are allowed. Defaults to 0."
  prntLn "    -R, --repo, --repository REPO\tSelect repository REPO which will be cloned. Defaults to existing repository under ${REPO_DIR}."

  logdebug "Options printed."
  return 0
}
